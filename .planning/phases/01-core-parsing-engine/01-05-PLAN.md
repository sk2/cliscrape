---
phase: 01-core-parsing-engine
plan: 05
type: execute
wave: 4
depends_on: ["01-03"]
files_modified: ["src/engine/macros.rs", "tests/template_macro_expansion.rs"]
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "Unit tests cover builtin {{mac_address}} macro expansion"
    - "Integration test proves Template::from_ir expands {{...}} inside rule regex and parse matches end-to-end"
  artifacts:
    - path: "src/engine/macros.rs"
      provides: "Builtin macro expansion + unit tests"
    - path: "tests/template_macro_expansion.rs"
      provides: "End-to-end macro expansion through Template::from_ir + Template::parse"
  key_links:
    - from: "src/engine/fsm.rs"
      to: "src/engine/macros.rs"
      via: "expand_macros called inside Template::from_ir"
      pattern: "expand_macros\("
    - from: "tests/template_macro_expansion.rs"
      to: "cliscrape::engine::Template::from_ir"
      via: "public API integration test"
      pattern: "Template::from_ir"
---

<objective>
Close the Phase 1 macro coverage gaps by adding a unit test for `{{mac_address}}` expansion and an integration test that proves macro expansion occurs during `Template::from_ir` and successfully parses input.

Purpose: Ensure macro library correctness and prevent regressions in the macro->compile->parse pipeline.
Output: New unit test in `src/engine/macros.rs` and new integration test in `tests/template_macro_expansion.rs`.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-core-parsing-engine/01-VERIFICATION.md
@src/engine/macros.rs
@src/engine/fsm.rs
@src/engine/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unit test for {{mac_address}} macro expansion</name>
  <files>src/engine/macros.rs</files>
  <action>
    In `src/engine/macros.rs` within the existing `#[cfg(test)] mod tests`, add a unit test (e.g. `test_mac_address_expansion`).

    Test requirements:
    - Call `expand_macros("MAC {{mac_address}}", &HashMap::new())`.
    - Assert the expanded regex string contains the builtin mac address pattern exactly as defined by `get_builtin_macros()`.
  </action>
  <verify>
    Run `cargo test engine::macros::tests::test_mac_address_expansion`.
  </verify>
  <done>
    There is explicit unit coverage for builtin `mac_address` expansion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration test proving Template::from_ir expands macros in rule regex</name>
  <files>tests/template_macro_expansion.rs</files>
  <action>
    Create `tests/template_macro_expansion.rs` as an integration test (new `tests/` directory if needed).

    Implement an end-to-end test that:
    - Builds a `TemplateIR` with:
      - a `Start` state containing a rule whose `regex` includes a builtin macro token like `{{mac_address}}` (and uses a named capture group, e.g. `(?P<Mac>{{mac_address}})` so results can be asserted)
      - `record_action: Action::Record`
      - `next_state: None`
      - empty `ir.macros` so builtins are used
    - Calls `Template::from_ir(ir)`.
    - Asserts the compiled rule regex string does NOT contain `{{mac_address}}` (proving macro expansion happened pre-compilation).
    - Parses a sample input line like `MAC aa:bb:cc:dd:ee:ff` and asserts:
      - exactly one record is returned
      - the record contains `Mac` with the expected value.

    Keep this test using only public crate APIs: import via `use cliscrape::engine::{Action, Rule, State, Template, TemplateIR};`.
  </action>
  <verify>
    Run `cargo test --test template_macro_expansion`.
  </verify>
  <done>
    There is an integration test proving `Template::from_ir` expands `{{...}}` inside rule regex and the resulting compiled regex matches real input.
  </done>
</task>

</tasks>

<verification>
- `cargo test engine::macros` passes.
- `cargo test --test template_macro_expansion` passes.
</verification>

<success_criteria>
- VERIFICATION gap #2 is closed: `{{mac_address}}` has unit coverage and macro expansion is proven end-to-end through compilation and parsing.
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-parsing-engine/01-05-SUMMARY.md`
</output>

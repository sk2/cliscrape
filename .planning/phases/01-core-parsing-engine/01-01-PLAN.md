---
phase: 01-core-parsing-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/lib.rs, src/engine/mod.rs, src/engine/types.rs, src/engine/macros.rs]
autonomous: true
must_haves:
  truths:
    - "Macros like {{ipv4}} in regex strings are correctly replaced with valid regex patterns before compilation"
    - "Template definitions correctly override built-in macros"
    - "Core data structures support Next, Continue, Record, and Clear actions"
  artifacts:
    - path: "src/engine/types.rs"
      provides: "Core FSM structs and enums"
    - path: "src/engine/macros.rs"
      provides: "Hardcoded regex library and expansion logic"
  key_links:
    - from: "src/engine/macros.rs"
      to: "Regex engine"
      via: "string replacement"
      pattern: "regex::Regex::new"
---

<objective>
Refactor the foundation of cliscrape to support a robust engine and implement the built-in regex macro system.

Purpose: Provide the structural base for the high-performance FSM and enable modular regex patterns without manual repetition.
Output: Core types and a functional macro expansion library.
</objective>

<execution_context>
@/Users/simonknight/.gemini/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/1-CONTEXT.md
@src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Engine Types</name>
  <files>src/engine/types.rs, src/engine/mod.rs, src/lib.rs</files>
  <action>
    Create src/engine/types.rs and migrate/expand types from src/lib.rs.
    - Define Value, Action, Rule, State, and Template structs.
    - Ensure Value supports name, regex_str, filldown, required.
    - Ensure Rule supports pattern (Regex), actions (Vec<Action>), and next_state (Option<String>).
    - Update src/lib.rs to export these via the engine module.
    - Action should include: Next, Continue, Record, Clear (following TextFSM terminology).
  </action>
  <verify>
    cargo check passes.
  </verify>
  <done>
    Types are defined in a dedicated module and accessible from the crate root.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Regex Macro Expansion</name>
  <files>src/engine/macros.rs</files>
  <action>
    Implement the macro expansion system in src/engine/macros.rs.
    - Create a hardcoded HashMap of internal macros:
      - ipv4: `(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)`
      - ipv6: `(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}` (Simplified)
      - mac: `(?:[0-9A-Fa-f]{2}[:-]){5}(?:[0-9A-Fa-f]{2})`
      - interface_name: `[A-Za-z]+[0-9]+(/[0-9]+)*`
    - Implement a function `expand_macros(pattern: &str) -> String` that replaces `{{name}}` with the macro value.
    - Add logic to allow template-defined values to override these (passed as a secondary map).
  </action>
  <verify>
    Add unit tests in macros.rs verifying:
    - {{ipv4}} expands correctly.
    - Multiple macros in one string expand.
    - Unknown macros are left as-is (or error, choose sensible default).
    - Custom overrides work.
  </verify>
  <done>
    Macro expansion is robust and tested.
  </done>
</task>

</tasks>

<verification>
- `cargo test` passes for the new modules.
- Types align with TextFSM behavior (Next/Continue/Record/Clear).
</verification>

<success_criteria>
The engine has a solid type system and can resolve modular regex patterns using the internal library.
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-parsing-engine/01-01-SUMMARY.md`
</output>

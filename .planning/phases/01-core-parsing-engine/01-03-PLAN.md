---
phase: 01-core-parsing-engine
plan: 03
type: execute
wave: 3
depends_on: [01-02]
files_modified: [src/engine/fsm.rs, src/engine/records.rs]
autonomous: true
must_haves:
  truths:
    - "Matched values are captured and stored as strings"
    - "The 'Record' action flushes the current capture buffer to the results list"
    - "Required values are checked before recording; if missing, record is dropped"
    - "Filldown values persist across records until cleared"
  artifacts:
    - path: "src/engine/records.rs"
      provides: "Record buffer and validation logic"
  key_links:
    - from: "src/engine/fsm.rs"
      to: "src/engine/records.rs"
      via: "capturing regex groups"
---

<objective>
Implement the logic for capturing values from regex matches and assembling them into final records, including validation and TextFSM-style persistence (Filldown).

Purpose: Complete the data extraction pipeline.
Output: A functional parser that returns Vec<HashMap<String, String>>.
</objective>

<execution_context>
@/Users/simonknight/.gemini/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/1-CONTEXT.md
@.planning/phases/01-core-parsing-engine/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Value Capturing and Record Buffer</name>
  <files>src/engine/records.rs, src/engine/fsm.rs</files>
  <action>
    Implement record buffering logic.
    - Create a RecordBuffer struct to hold currently captured values.
    - Implement logic to map regex named capture groups to Value names.
    - Implement 'Filldown' behavior: values marked as filldown are not cleared after a 'Record' action.
    - Implement 'Clear' action: resets specified values (or all non-filldown values).
  </action>
  <verify>
    cargo check passes.
  </verify>
  <done>
    Values are correctly captured and buffered during FSM execution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Record Validation and Throughput Benchmark</name>
  <files>src/engine/fsm.rs, benches/throughput.rs</files>
  <action>
    Finalize the 'Record' action and add benchmarking.
    - Implement 'Required' validation: before adding a record to the final list, check if all values marked 'Required' are present. If not, discard the record.
    - Create a basic benchmark using `criterion` or a simple `Instant` loop in a test.
    - Benchmark goal: >100,000 lines per second on a representative template/input.
  </action>
  <verify>
    - Unit tests for Required and Filldown logic.
    - Benchmark output showing lines/sec.
  </verify>
  <done>
    Records are validated and the engine meets performance targets.
  </done>
</task>

</tasks>

<verification>
- `cargo test` passes.
- Integration test with a sample Cisco output (e.g. `show interfaces`) matches expected JSON output.
</verification>

<success_criteria>
The engine produces correct structured data from text input, respecting TextFSM capture rules, and meets the performance goal.
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-parsing-engine/01-03-SUMMARY.md`
</output>

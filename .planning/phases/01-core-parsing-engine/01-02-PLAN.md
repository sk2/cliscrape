---
phase: 01-core-parsing-engine
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: ["src/engine/mod.rs", "src/engine/fsm.rs", "src/engine/types.rs"]
autonomous: true
must_haves:
  truths:
    - "Template compilation transforms ${Value} to named capture groups"
    - "FSM 'Continue' action allows matching multiple rules on one line"
    - "Invalid state transitions return an Error"
  artifacts:
    - path: "src/engine/fsm.rs"
      provides: "FSM execution logic"
  key_links:
    - from: "src/engine/fsm.rs"
      to: "src/engine/types.rs"
      via: "Template and CompiledRule types"
---

<objective>
Implement the core Finite State Machine (FSM) execution loop and regex compilation logic.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-parsing-engine/01-CONTEXT.md
@.planning/phases/01-core-parsing-engine/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Template Compilation</name>
  <files>src/engine/types.rs, src/engine/fsm.rs</files>
  <action>
    Implement logic to compile raw State/Rule definitions into a runnable Template.
    1. Define `CompiledRule` in `src/engine/types.rs` to hold pre-compiled `regex::Regex`.
    2. Define `Template` struct in `src/engine/fsm.rs` (or types.rs) to store `HashMap<String, Vec<CompiledRule>>` and metadata.
    3. Implement `Template::from_ir`:
       - Expand macros in rules using `expand_macros`.
       - Replace `${ValueName}` with `(?P<ValueName>...regex...)` from Value definitions.
       - Compile final regexes.
       - Validate all `next_state` targets exist.
  </action>
  <verify>
    Add unit test verifying `${Value}` is correctly converted to a named capture group in the compiled regex.
  </verify>
  <done>
    Templates can be compiled from IR, transforming value references and macros into valid Regex objects.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement FSM Execution Loop</name>
  <files>src/engine/fsm.rs</files>
  <action>
    Implement the core parsing loop in `src/engine/fsm.rs`.
    1. Implement `parse(template: &Template, input: &str) -> Result<Vec<HashMap<String, String>>, ScraperError>`.
    2. Logic:
       - Start in "Start" state.
       - Iterate input lines.
       - For each line, iterate rules in current state.
       - On match:
         - Handle `Action::Next` (default): move to next line.
         - Handle `Action::Continue`: continue matching rules on the same line.
         - Update current state if specified.
       - On no match: Discard line and continue.
  </action>
  <verify>
    Unit test with a `Continue` action showing that one line can trigger multiple rules.
  </verify>
  <done>
    The FSM execution loop correctly processes input lines and manages state transitions.
  </done>
</task>

</tasks>

<verification>
- Unit test for named capture group transformation passes.
- Unit test for `Continue` action logic passes.
- Invalid state transitions return `Err`.
</verification>

<success_criteria>
The engine correctly processes text using state-based logic and pre-compiled regexes with named capture groups.
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-parsing-engine/01-02-SUMMARY.md`
</output>

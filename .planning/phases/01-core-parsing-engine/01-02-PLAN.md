---
phase: 01-core-parsing-engine
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified: [src/engine/mod.rs, src/engine/fsm.rs]
autonomous: true
must_haves:
  truths:
    - "The engine processes input line-by-line"
    - "Matching a rule triggers state transitions if defined"
    - "The engine stays in the current state if no rules match"
    - "Deterministic transitions: first matching rule in current state wins"
  artifacts:
    - path: "src/engine/fsm.rs"
      provides: "FsmRunner implementation"
  key_links:
    - from: "src/engine/fsm.rs"
      to: "src/engine/types.rs"
      via: "State/Rule processing"
---

<objective>
Implement the core FSM execution loop that drives line-by-line processing and state transitions.

Purpose: Achieve the "High Throughput" goal by implementing a lean processing loop.
Output: An FSM runner capable of executing transitions based on matching rules.
</objective>

<execution_context>
@/Users/simonknight/.gemini/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/1-CONTEXT.md
@.planning/phases/01-core-parsing-engine/01-01-SUMMARY.md
@src/engine/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FsmRunner</name>
  <files>src/engine/fsm.rs, src/engine/mod.rs</files>
  <action>
    Create src/engine/fsm.rs and implement the core execution logic.
    - Create an FsmRunner struct that holds the Template and current state.
    - Implement `process_line(&mut self, line: &str)`.
    - Logic:
      1. Iterate through rules in the current state.
      2. If a rule's regex matches:
         - Capture named groups into a temporary buffer.
         - Store the actions (Record, Clear, etc. - to be handled in next plan).
         - Update current state to next_state if specified.
         - If action is not 'Continue', break (first match wins).
      3. If no rule matches, proceed to next line.
  </action>
  <verify>
    cargo check passes.
  </verify>
  <done>
    FsmRunner can cycle through states based on input matches.
  </done>
</task>

<task type="auto">
  <name>Task 2: State Transition Tests</name>
  <files>src/engine/fsm.rs</files>
  <action>
    Add unit tests to verify deterministic transitions.
    - Create a multi-state template (e.g., Start -> Header -> Body -> End).
    - Provide input lines that trigger transitions.
    - Assert the FsmRunner is in the expected state after each line.
    - Verify that 'Next' (default) vs 'Continue' behavior works (breaking vs continuing through rules).
  </action>
  <verify>
    cargo test passes.
  </verify>
  <done>
    Transitions are verified to be deterministic and correct.
  </done>
</task>

</tasks>

<verification>
- `cargo test` passes.
- Unit tests cover multiple states and transition rules.
</verification>

<success_criteria>
The engine correctly navigates a multi-state template based on regex matches.
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-parsing-engine/01-02-SUMMARY.md`
</output>

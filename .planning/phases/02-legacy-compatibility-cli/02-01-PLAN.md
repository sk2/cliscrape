---
phase: 02-legacy-compatibility-cli
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [Cargo.toml, src/lib.rs, src/template/textfsm.pest, src/template/loader.rs, src/template/mod.rs]
autonomous: true

must_haves:
  truths:
    - "TextFSM templates with multiple Values are parsed into TemplateIR"
    - "States and Rules (including line/record actions) are correctly mapped from Pest grammar"
    - "Templates with regex macros {{name}} are supported in the TextFSM loader"
  artifacts:
    - path: "src/template/textfsm.pest"
      provides: "Pest grammar for legacy TextFSM"
    - path: "src/template/loader.rs"
      provides: "TextFsmLoader implementation"
  key_links:
    - from: "src/lib.rs"
      to: "src/template/loader.rs"
      via: "FsmParser::from_file"
---

<objective>
Implement a legacy TextFSM template parser using the Pest grammar generator. This will allow the engine to load existing `.textfsm` files and convert them into our internal `TemplateIR`.

Purpose: Enable compatibility with thousands of existing NTC templates.
Output: A functional TextFsmLoader and a Pest grammar file.
</objective>

<execution_context>
@/Users/simonknight/.gemini/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/engine/types.rs
@src/engine/fsm.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pest Grammar Definition</name>
  <files>Cargo.toml, src/template/textfsm.pest, src/template/mod.rs</files>
  <action>
    1. Add `pest = "2.7"` and `pest_derive = "2.7"` to Cargo.toml.
    2. Create `src/template/textfsm.pest` with rules for:
       - Value definitions: `Value [List|Filldown|Required]* Name (Regex)`
       - State definitions: `StateName`
       - Rule lines: `^ ^Regex (-> Action)`
       - Actions: `Next|Continue`, `Record|Clear|NoRecord`, `NewState`
       - Comments and whitespace.
    3. Create `src/template/mod.rs` to export the module and define the Pest Parser struct.
  </action>
  <verify>Run `cargo check` to ensure pest_derive generates the parser correctly.</verify>
  <done>Grammar compiles and correctly tokensizes a sample TextFSM file.</done>
</task>

<task type="auto">
  <name>Task 2: Implement TextFsmLoader</name>
  <files>src/template/loader.rs, src/engine/types.rs</files>
  <action>
    1. Implement `TextFsmLoader::parse_str(input: &str) -> Result<TemplateIR, ScraperError>`.
    2. Use the Pest parser to iterate over pairs:
       - Map `Value` definitions to `HashMap<String, Value>`.
       - Map `State` blocks to `HashMap<String, State>`.
       - Handle TextFSM-specific action syntax (e.g., `-> Record`, `-> Next.Record`, `-> Continue.Record StateName`).
    3. Ensure support for implicit `Next.NoRecord` when no action is specified.
    4. Handle line-leading `^` and `^ ^` correctly (TextFSM rule markers).
  </action>
  <verify>Create a unit test in `loader.rs` that parses a multi-state template and verifies the resulting `TemplateIR` structure matches expectations.</verify>
  <done>Loader converts a `.textfsm` string into a valid `TemplateIR` with correct states, rules, and actions.</done>
</task>

<task type="auto">
  <name>Task 3: Integration with FsmParser</name>
  <files>src/lib.rs, src/template/mod.rs</files>
  <action>
    1. Update `src/lib.rs` to include `pub mod template`.
    2. Implement `FsmParser::from_file<P: AsRef<Path>>(path: P)`:
       - Read file content.
       - If extension is `.textfsm`, use `TextFsmLoader`.
       - Convert `TemplateIR` to `Template` and return `FsmParser`.
  </action>
  <verify>Run `cargo test` and ensure existing tests pass, then add a small integration test using a file path.</verify>
  <done>User can load a TextFSM template from a file path using the library API.</done>
</task>

</tasks>

<verification>
1. `cargo test` passes.
2. Unit tests in `loader.rs` cover multiple Value types (Filldown, Required) and complex actions (Continue, state transitions).
</verification>

<success_criteria>
- `.textfsm` files can be loaded into the engine.
- All core TextFSM actions (`Next`, `Continue`, `Record`, `Clear`) are correctly mapped.
- Template IR correctly represents the structure of the input file.
</success_criteria>

<output>
After completion, create `.planning/phases/02-legacy-compatibility-cli/02-01-SUMMARY.md`
</output>

---
phase: 02-legacy-compatibility-cli
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [src/main.rs, src/cli.rs, src/engine/fsm.rs]
autonomous: true

must_haves:
  truths:
    - "cliscrape parse --template <path> <input> output JSON by default"
    - "cliscrape accepts input from stdin (piped)"
    - "The last row is recorded upon EOF even if no explicit Record action matched"
  artifacts:
    - path: "src/cli.rs"
      provides: "Clap CLI definition"
    - path: "src/main.rs"
      provides: "CLI entrypoint and IO handling"
  key_links:
    - from: "src/main.rs"
      to: "src/lib.rs"
      via: "FsmParser::parse"
---

<objective>
Implement the Command Line Interface (CLI) and handle implicit EOF recording. This allows users to use cliscrape as a standalone tool and ensures compliance with TextFSM's "record on exit" behavior.

Purpose: Turn the engine into a usable tool.
Output: A functional `cliscrape` binary with `parse` command.
</objective>

<execution_context>
@/Users/simonknight/.gemini/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib.rs
@src/engine/fsm.rs
@.planning/phases/02-legacy-compatibility-cli/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CLI Structure</name>
  <files>src/main.rs, src/cli.rs</files>
  <action>
    1. Define `Cli` struct in `src/cli.rs` using `clap`:
       - Subcommand `parse`:
         - `--template` / `-t` (required): Path to .textfsm file.
         - `input`: Optional path to input text (if missing, use stdin).
         - `--format` / `-f`: Output format (default: json).
    2. Update `src/main.rs` to parse arguments and initialize the `FsmParser`.
  </action>
  <verify>`cargo run -- --help` shows the parse command and its options.</verify>
  <done>CLI structure is defined and command line arguments are correctly parsed.</done>
</task>

<task type="auto">
  <name>Task 2: Handle Input Streaming</name>
  <files>src/main.rs</files>
  <action>
    1. Implement logic in `main.rs` to read from a file if provided, otherwise from `std::io::stdin()`.
    2. Stream the input into a string (or process line-by-line if engine supports it - currently `parse` takes `&str`).
    3. Call `parser.parse(&input_str)` and print the result (using `serde_json` for now).
  </action>
  <verify>Run `echo "some data" | cargo run -- parse -t template.textfsm` and verify it attempts to parse (even if it fails due to template contents).</verify>
  <done>Tool correctly handles both file paths and piped stdin input.</done>
</task>

<task type="auto">
  <name>Task 3: Implement Implicit EOF Record</name>
  <files>src/engine/fsm.rs</files>
  <action>
    1. Modify `Template::parse` in `src/engine/fsm.rs`.
    2. After the main line-processing loop finishes, check if `record_buffer` contains any data that hasn't been emitted.
    3. If there is data, call `record_buffer.emit(&self.values)` and push to `results` if it returns a record.
    4. Ensure this matches TextFSM's behavior: EOF acts as an implicit `Record` unless an explicit `EOF` state transition was defined (we will skip EOF state for now as per research).
  </action>
  <verify>Add a test case in `fsm.rs` where the last line matches a rule that doesn't have a `Record` action, and verify the record is still present in results.</verify>
  <done>Final records are captured correctly when the input stream ends.</done>
</task>

</tasks>

<verification>
1. `cliscrape parse --template test.fsm data.txt` produces JSON.
2. `cat data.txt | cliscrape parse --template test.fsm` produces JSON.
3. Unit tests for EOF logic pass.
</verification>

<success_criteria>
- The tool can be used from the command line.
- Piped input works as expected.
- Legacy templates that rely on EOF to record the last row work correctly.
</success_criteria>

<output>
After completion, create `.planning/phases/02-legacy-compatibility-cli/02-02-SUMMARY.md`
</output>

---
phase: 07-compatibility-validation-suite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - tests/validation.rs
  - tests/fixtures/cisco/ios_show_version/ios_15_standard.txt
  - tests/fixtures/cisco/ios_show_version/ios_12_legacy.txt
  - tests/fixtures/juniper/junos_show_version/junos_12_standard.txt
autonomous: true
requirements: [VAL-01]

must_haves:
  truths:
    - "Developer can run cargo test --test validation to verify all embedded templates"
    - "Developer can review snapshot changes via cargo insta review"
    - "Developer sees fixture-specific snapshot files for each test case"
  artifacts:
    - path: "tests/validation.rs"
      provides: "Snapshot test suite for all embedded templates"
      min_lines: 50
    - path: "tests/fixtures/cisco/ios_show_version/ios_15_standard.txt"
      provides: "Real device output fixture"
      contains: "Cisco IOS Software"
    - path: "Cargo.toml"
      provides: "insta and cargo-insta dependencies"
      contains: "insta"
  key_links:
    - from: "tests/validation.rs"
      to: "templates/cisco_ios_show_version.yaml"
      via: "include_str macro"
      pattern: "include_str.*templates/"
    - from: "tests/validation.rs"
      to: "tests/fixtures/"
      via: "include_str for input fixtures"
      pattern: "include_str.*fixtures/"
---

<objective>
Establish snapshot testing infrastructure for validating embedded templates against real device outputs.

Purpose: Enable regression detection and ensure templates produce consistent, reviewable parsing results across code changes.

Output: Working snapshot test suite with insta framework, vendor-organized fixture directory, and initial test fixtures for all 5 embedded templates.
</objective>

<execution_context>
@/Users/simonknight/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-compatibility-validation-suite/07-CONTEXT.md
@.planning/phases/07-compatibility-validation-suite/07-RESEARCH.md
@.planning/phases/06-template-library-foundation/06-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add insta dependencies and create fixture directory structure</name>
  <files>
    Cargo.toml
    tests/fixtures/cisco/ios_show_version/.gitkeep
    tests/fixtures/cisco/ios_show_interfaces/.gitkeep
    tests/fixtures/cisco/nxos_show_version/.gitkeep
    tests/fixtures/juniper/junos_show_version/.gitkeep
    tests/fixtures/arista/eos_show_version/.gitkeep
  </files>
  <action>
Add insta and cargo-insta to dev-dependencies in Cargo.toml:

```toml
[dev-dependencies]
insta = { version = "1", features = ["yaml", "json"] }
```

Create vendor-first fixture directory structure per CONTEXT.md decision:
- tests/fixtures/&lt;vendor&gt;/&lt;template&gt;/
- Vendors: cisco, juniper, arista
- Templates matching existing embedded templates (5 total)
- Create .gitkeep files in each directory to ensure they're tracked

Use CONTEXT.md locked decision: "Directory structure: tests/fixtures/&lt;vendor&gt;/&lt;template&gt;/ (vendor-first organization mirrors real-world device taxonomy)".

Do NOT install cargo-insta globally yet - that will be handled in separate CI task.
  </action>
  <verify>
cargo tree | grep insta
ls -R tests/fixtures/
  </verify>
  <done>
insta 1.x appears in dependency tree with yaml and json features. Fixture directories exist for all 5 templates following vendor/template hierarchy. .gitkeep files present.
  </done>
</task>

<task type="auto">
  <name>Create real device output fixtures for positive test cases</name>
  <files>
    tests/fixtures/cisco/ios_show_version/ios_15_standard.txt
    tests/fixtures/cisco/ios_show_version/ios_12_legacy.txt
    tests/fixtures/cisco/ios_show_interfaces/ios_15_standard.txt
    tests/fixtures/cisco/nxos_show_version/nxos_9_standard.txt
    tests/fixtures/juniper/junos_show_version/junos_12_standard.txt
    tests/fixtures/arista/eos_show_version/eos_4_standard.txt
  </files>
  <action>
Create realistic device output fixtures for all 5 embedded templates. Use CONTEXT.md locked decision: "Descriptive names (e.g., show_version_ios_15.txt)".

For each template, create 1-2 fixture files representing:
1. Standard/modern version output
2. Legacy/older version output (for ios_show_version only)

Fixtures should be hand-crafted but realistic, matching the format that actual network devices produce. Base content on the compatibility metadata in each template (e.g., "Cisco IOS 12.x, 15.x, IOS-XE").

**cisco_ios_show_version.yaml** fixtures:
- ios_15_standard.txt: IOS 15.x output with all fields (version, hostname, uptime, serial, model)
- ios_12_legacy.txt: IOS 12.x output with slightly different formatting

**cisco_ios_show_interfaces.yaml** fixtures:
- ios_15_standard.txt: Show interfaces output with 2-3 interface blocks

**cisco_nxos_show_version.yaml** fixtures:
- nxos_9_standard.txt: NX-OS 9.x output

**juniper_junos_show_version.yaml** fixtures:
- junos_12_standard.txt: Junos 12.x output

**arista_eos_show_version.yaml** fixtures:
- eos_4_standard.txt: EOS 4.x output

Use realistic values (hostnames, serials, uptimes) that would appear in production environments.
  </action>
  <verify>
wc -l tests/fixtures/**/*.txt
grep -r "version\|Version" tests/fixtures/ | head -5
  </verify>
  <done>
6 fixture files created with realistic device output content. Each fixture contains version strings and device-specific data matching template expectations.
  </done>
</task>

<task type="auto">
  <name>Create validation test suite with snapshot assertions</name>
  <files>
    tests/validation.rs
  </files>
  <action>
Create tests/validation.rs implementing snapshot testing for all embedded templates using Pattern 1 from RESEARCH.md.

Use CONTEXT.md locked decisions:
- "Use insta crate for snapshot testing"
- "Pairing strategy: Input + JSON snapshot via insta"
- "Manual review required for snapshot updates"

Structure:
1. Import insta::assert_yaml_snapshot and project types (FsmParser, TemplateFormat)
2. Create one test function per fixture file (6 tests total)
3. Each test:
   - Load template via include_str!("../templates/&lt;name&gt;.yaml")
   - Load fixture via include_str!("fixtures/&lt;vendor&gt;/&lt;template&gt;/&lt;file&gt;.txt")
   - Create parser: FsmParser::from_str(template, TemplateFormat::Yaml).unwrap()
   - Parse input: parser.parse(input).unwrap()
   - Snapshot results: assert_yaml_snapshot!(results)

Test naming convention: test_&lt;vendor&gt;_&lt;template&gt;_&lt;variant&gt; (e.g., test_cisco_ios_show_version_ios_15_standard)

Use external snapshots (not inline) per RESEARCH.md recommendation: "Use external snapshots in snapshots/ directory (not inline)" for better diff visualization.

Do NOT add coverage validation yet - that's a separate plan. This task focuses only on snapshot testing infrastructure (VAL-01).
  </action>
  <verify>
cargo test --test validation -- --nocapture
ls snapshots/
  </verify>
  <done>
validation.rs compiles successfully. cargo test --test validation passes and generates .snap files in snapshots/ directory. One snapshot per fixture. All tests use assert_yaml_snapshot! with external storage.
  </done>
</task>

</tasks>

<verification>
Run complete validation test suite:
```bash
cargo test --test validation
```

Verify snapshot files were generated:
```bash
ls snapshots/ | grep validation
```

Verify fixture organization:
```bash
tree tests/fixtures/
```

Verify insta dependency:
```bash
cargo tree | grep insta
```
</verification>

<success_criteria>
- insta crate with yaml and json features in dev-dependencies
- Fixture directory structure follows vendor/template hierarchy
- 6 fixture files with realistic device output content
- 6 snapshot tests in tests/validation.rs
- cargo test --test validation passes
- Snapshot files (.snap) generated in snapshots/ directory
- Test output shows template parsing results for manual inspection
</success_criteria>

<output>
After completion, create `.planning/phases/07-compatibility-validation-suite/07-01-SUMMARY.md`
</output>

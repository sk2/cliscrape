---
phase: 07-compatibility-validation-suite
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/validation.rs
  - tests/fixtures/cisco/ios_show_version/negative/truncated_output.txt
  - tests/fixtures/cisco/ios_show_version/negative/malformed_version.txt
  - tests/fixtures/cisco/ios_show_version/negative/empty_input.txt
  - tests/fixtures/cisco/nxos_show_version/negative/truncated_output.txt
  - tests/fixtures/juniper/junos_show_version/negative/malformed_hostname.txt
autonomous: true
requirements: [VAL-02]

must_haves:
  truths:
    - "Developer can verify parser rejects malformed input with appropriate errors"
    - "Developer can detect unintended error message changes via snapshot testing"
    - "Developer can add new negative test cases by creating fixture files in negative/ subdirectories"
  artifacts:
    - path: "tests/validation.rs"
      provides: "Negative test cases with error assertions"
      contains: "test_negative_case"
    - path: "tests/fixtures/cisco/ios_show_version/negative/truncated_output.txt"
      provides: "Error test fixture"
      min_lines: 1
  key_links:
    - from: "tests/validation.rs"
      to: "tests/fixtures/*/negative/"
      via: "include_str for negative fixtures"
      pattern: "negative/"
---

<objective>
Add comprehensive negative test coverage to catch parser errors and edge cases.

Purpose: Ensure parser fails gracefully on malformed input, truncated output, and edge cases with descriptive error messages that don't regress.

Output: Negative test suite with 10+ error fixtures covering truncation, malformed input, empty input, and template-specific edge cases.
</objective>

<execution_context>
@/Users/simonknight/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-compatibility-validation-suite/07-CONTEXT.md
@.planning/phases/07-compatibility-validation-suite/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create negative test fixtures in negative/ subdirectories</name>
  <files>
    tests/fixtures/cisco/ios_show_version/negative/truncated_output.txt
    tests/fixtures/cisco/ios_show_version/negative/malformed_version.txt
    tests/fixtures/cisco/ios_show_version/negative/empty_input.txt
    tests/fixtures/cisco/ios_show_version/negative/invalid_uptime.txt
    tests/fixtures/cisco/ios_show_interfaces/negative/truncated_output.txt
    tests/fixtures/cisco/ios_show_interfaces/negative/missing_status.txt
    tests/fixtures/cisco/nxos_show_version/negative/truncated_output.txt
    tests/fixtures/cisco/nxos_show_version/negative/malformed_serial.txt
    tests/fixtures/juniper/junos_show_version/negative/malformed_hostname.txt
    tests/fixtures/juniper/junos_show_version/negative/empty_input.txt
    tests/fixtures/arista/eos_show_version/negative/truncated_output.txt
    tests/fixtures/arista/eos_show_version/negative/malformed_model.txt
  </files>
  <action>
Create negative test fixtures following CONTEXT.md locked decisions:
- "Storage location: Separate negative/ subdirectories under each template"
- "Error coverage: Comprehensive (malformed input, truncated output, parser failures, edge cases)"

Apply RESEARCH.md recommendation: "3-5 negative tests per template minimum" covering:
1. Truncated output (required field missing)
2. Malformed input (unexpected format)
3. Empty input
4. Edge case specific to template (e.g., invalid value format)

For each template's negative/ subdirectory:

**cisco_ios_show_version/negative/**:
- truncated_output.txt: Output cut off before serial number (required field)
- malformed_version.txt: Version string in unexpected format
- empty_input.txt: Completely empty file
- invalid_uptime.txt: Uptime in wrong format

**cisco_ios_show_interfaces/negative/**:
- truncated_output.txt: Interface block cut off mid-way
- missing_status.txt: Interface without status line

**cisco_nxos_show_version/negative/**:
- truncated_output.txt: Missing model information
- malformed_serial.txt: Serial in unexpected format

**juniper_junos_show_version/negative/**:
- malformed_hostname.txt: Hostname line missing
- empty_input.txt: Empty file

**arista_eos_show_version/negative/**:
- truncated_output.txt: Version missing
- malformed_model.txt: Model in wrong format

Each fixture should be realistic but intentionally broken to trigger specific error conditions.
  </action>
  <verify>
ls -R tests/fixtures/*/negative/
wc -l tests/fixtures/*/negative/*.txt
  </verify>
  <done>
12 negative test fixtures created across 5 templates. Each template has 2-4 error cases. negative/ subdirectories exist under each template directory.
  </done>
</task>

<task type="auto">
  <name>Add negative test cases with error assertions and snapshots</name>
  <files>
    tests/validation.rs
  </files>
  <action>
Add negative test cases to tests/validation.rs using Pattern 2 from RESEARCH.md and CONTEXT.md locked decision: "Validation approach: Both error type assertion AND message snapshotting".

Add helper function for negative test cases:
```rust
fn test_negative_case(template_path: &str, fixture_path: &str) {
    let template_content = include_str!(template_path);
    let input = include_str!(fixture_path);

    let parser = FsmParser::from_str(template_content, TemplateFormat::Yaml).unwrap();
    let result = parser.parse(input);

    // Assert error type (strict validation)
    assert!(result.is_err(), "Should fail on invalid input");

    // Snapshot error message for regression detection
    let err = result.unwrap_err();
    assert_yaml_snapshot!(format!("{:?}", err));
}
```

Create one test per negative fixture (12 tests total):
- test_cisco_ios_show_version_truncated_output
- test_cisco_ios_show_version_malformed_version
- test_cisco_ios_show_version_empty_input
- test_cisco_ios_show_version_invalid_uptime
- test_cisco_ios_show_interfaces_truncated_output
- test_cisco_ios_show_interfaces_missing_status
- test_cisco_nxos_show_version_truncated_output
- test_cisco_nxos_show_version_malformed_serial
- test_juniper_junos_show_version_malformed_hostname
- test_juniper_junos_show_version_empty_input
- test_arista_eos_show_version_truncated_output
- test_arista_eos_show_version_malformed_model

Each test calls test_negative_case with appropriate template and fixture paths.

Use assert!(result.is_err()) to verify parser returns error (not success or panic).
Use assert_yaml_snapshot! on formatted error to catch message regressions.

Note: Empty input tests may return Ok(vec![]) rather than Err if parser allows empty results - verify actual behavior and adjust assertions accordingly.
  </action>
  <verify>
cargo test --test validation negative
ls snapshots/ | grep negative
  </verify>
  <done>
validation.rs contains 12 negative test cases using test_negative_case helper. cargo test --test validation shows negative tests passing. Error message snapshots created in snapshots/ directory.
  </done>
</task>

</tasks>

<verification>
Run negative test suite:
```bash
cargo test --test validation negative
```

Verify all negative tests generate error snapshots:
```bash
ls snapshots/ | grep negative | wc -l
```

Verify fixture organization:
```bash
find tests/fixtures -name "negative" -type d
```

Check that errors are descriptive (manual inspection):
```bash
cargo test --test validation negative -- --nocapture 2>&1 | grep -A 2 "assertion failed"
```
</verification>

<success_criteria>
- 12 negative test fixtures in negative/ subdirectories
- 12 negative test cases in validation.rs
- All negative tests assert result.is_err()
- All negative tests snapshot error messages
- cargo test --test validation passes (both positive and negative tests)
- Error snapshots exist in snapshots/ directory
- Parser fails gracefully on all error cases (no panics)
</success_criteria>

<output>
After completion, create `.planning/phases/07-compatibility-validation-suite/07-02-SUMMARY.md`
</output>

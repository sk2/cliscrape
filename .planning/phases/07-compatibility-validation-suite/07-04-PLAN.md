---
phase: 07-compatibility-validation-suite
plan: 04
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - tests/validation.rs
  - tests/coverage.rs
autonomous: true
requirements: [VAL-05]

must_haves:
  truths:
    - "Developer sees warnings when template captures fewer fields than threshold"
    - "Developer receives actionable feedback listing missing fields"
    - "Developer can identify templates with incomplete parsing"
  artifacts:
    - path: "tests/validation.rs"
      provides: "Coverage validation in snapshot tests"
      contains: "calculate_coverage"
    - path: "tests/coverage.rs"
      provides: "Coverage calculation test suite"
      min_lines: 30
  key_links:
    - from: "tests/validation.rs"
      to: "FsmParser::field_names()"
      via: "method call to get expected fields"
      pattern: "field_names\\(\\)"
---

<objective>
Add field coverage validation to detect incomplete template parsing.

Purpose: Warn developers when templates fail to capture expected fields, enabling early detection of template/input mismatches.

Output: Coverage calculation system with configurable thresholds (default 80%) and actionable warning messages listing missing fields.
</objective>

<execution_context>
@/Users/simonknight/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-compatibility-validation-suite/07-CONTEXT.md
@.planning/phases/07-compatibility-validation-suite/07-RESEARCH.md
@.planning/phases/07-compatibility-validation-suite/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create coverage calculation module in validation tests</name>
  <files>
    tests/coverage.rs
  </files>
  <action>
Create tests/coverage.rs implementing coverage calculation per RESEARCH.md example and CONTEXT.md decisions.

Use CONTEXT.md locked decisions:
- "Threshold enforcement: Configurable per template (default: 80%)"
- "Expected fields definition: Hybrid approach (template YAML fields serve as baseline)"
- "Warning message content: Stats + missing fields + suggestions"

Implement CoverageReport struct and calculate_coverage function:

```rust
use std::collections::HashMap;
use serde_json::Value;

#[derive(Debug, Clone)]
pub struct CoverageReport {
    pub percentage: f64,
    pub captured_fields: Vec<String>,
    pub missing_fields: Vec<String>,
    pub total_expected: usize,
}

pub fn calculate_coverage(
    parsed_record: &HashMap<String, Value>,
    template_fields: &[String],
) -> CoverageReport {
    let captured: Vec<String> = parsed_record.keys().cloned().collect();
    let missing: Vec<String> = template_fields
        .iter()
        .filter(|field| !parsed_record.contains_key(*field))
        .cloned()
        .collect();

    let percentage = if template_fields.is_empty() {
        100.0  // Edge case: no expected fields
    } else {
        (captured.len() as f64 / template_fields.len() as f64) * 100.0
    };

    CoverageReport {
        percentage,
        captured_fields: captured,
        missing_fields: missing,
        total_expected: template_fields.len(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_coverage_full() {
        let mut record = HashMap::new();
        record.insert("version".to_string(), Value::String("15.0".to_string()));
        record.insert("hostname".to_string(), Value::String("router1".to_string()));

        let fields = vec!["version".to_string(), "hostname".to_string()];
        let report = calculate_coverage(&record, &fields);

        assert_eq!(report.percentage, 100.0);
        assert_eq!(report.missing_fields.len(), 0);
    }

    #[test]
    fn test_calculate_coverage_partial() {
        let mut record = HashMap::new();
        record.insert("version".to_string(), Value::String("15.0".to_string()));

        let fields = vec!["version".to_string(), "hostname".to_string(), "serial".to_string()];
        let report = calculate_coverage(&record, &fields);

        assert!((report.percentage - 33.33).abs() < 0.1);
        assert_eq!(report.missing_fields.len(), 2);
        assert!(report.missing_fields.contains(&"hostname".to_string()));
        assert!(report.missing_fields.contains(&"serial".to_string()));
    }

    #[test]
    fn test_calculate_coverage_empty_template() {
        let record = HashMap::new();
        let fields: Vec<String> = vec![];
        let report = calculate_coverage(&record, &fields);

        assert_eq!(report.percentage, 100.0);  // Edge case
    }
}
```

This module provides reusable coverage calculation for use in validation.rs tests.

Per RESEARCH.md recommendation: "Calculate at test-time only (not runtime)" - this is test infrastructure only.
  </action>
  <verify>
cargo test --test coverage
  </verify>
  <done>
coverage.rs exists with CoverageReport struct and calculate_coverage function. Unit tests pass verifying full coverage (100%), partial coverage (33%), and empty template edge case.
  </done>
</task>

<task type="auto">
  <name>Integrate coverage validation into snapshot tests</name>
  <files>
    tests/validation.rs
  </files>
  <action>
Update tests/validation.rs to add coverage validation to all positive test cases using RESEARCH.md pattern and CONTEXT.md decision: "Configurable per template (default: 80%)".

Add module declaration at top:
```rust
mod coverage;
use coverage::{calculate_coverage, CoverageReport};
```

Update each positive test to include coverage assertion after snapshot. Example:

```rust
#[test]
fn test_cisco_ios_show_version_ios_15_standard() {
    let template_content = include_str!("../templates/cisco_ios_show_version.yaml");
    let input = include_str!("fixtures/cisco/ios_show_version/ios_15_standard.txt");

    let parser = FsmParser::from_str(template_content, TemplateFormat::Yaml).unwrap();
    let results = parser.parse(input).unwrap();

    // Snapshot the JSON output
    assert_yaml_snapshot!(results);

    // Validate field coverage (80% threshold)
    if !results.is_empty() {
        let report = calculate_coverage(&results[0], &parser.field_names());
        assert!(
            report.percentage >= 80.0,
            "Coverage {:.1}% below 80% threshold\n\
             Missing fields: {:?}\n\
             Captured: {}/{} fields\n\
             Suggestions: Check regex patterns for missing fields",
            report.percentage,
            report.missing_fields,
            report.captured_fields.len(),
            report.total_expected
        );
    }
}
```

Apply coverage validation to all 6 positive test cases from 07-01.

Use 80% threshold for all templates (default per CONTEXT.md).

Warning message includes:
- Coverage percentage
- Missing field names
- Captured vs total count
- Actionable suggestion

Skip coverage check if results.is_empty() to handle edge cases gracefully.

Do NOT modify negative tests - they should fail parsing, so coverage doesn't apply.
  </action>
  <verify>
cargo test --test validation
  </verify>
  <done>
validation.rs includes coverage validation in all 6 positive tests. cargo test --test validation passes with coverage assertions. Tests fail if coverage drops below 80% with descriptive error messages listing missing fields.
  </done>
</task>

</tasks>

<verification>
Run validation tests with coverage:
```bash
cargo test --test validation
```

Verify coverage module compiles:
```bash
cargo test --test coverage
```

Test coverage failure manually by temporarily setting threshold to 100%:
```bash
# Should see descriptive error with missing fields
```

Check that empty results don't cause panics:
```bash
cargo test --test validation -- --nocapture | grep -i coverage
```
</verification>

<success_criteria>
- tests/coverage.rs exists with CoverageReport struct and calculate_coverage function
- Unit tests for coverage calculation pass (full, partial, empty edge cases)
- All 6 positive validation tests include coverage assertions
- Coverage threshold set to 80% (default per CONTEXT.md)
- Warning messages include percentage, missing fields, and suggestions
- cargo test --test validation passes
- Tests fail gracefully with actionable messages if coverage drops below threshold
</success_criteria>

<output>
After completion, create `.planning/phases/07-compatibility-validation-suite/07-04-SUMMARY.md`
</output>

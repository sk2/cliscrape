---
phase: 06-template-library-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/template/mod.rs
  - src/template/library.rs
  - src/template/resolver.rs
autonomous: true
requirements:
  - LIB-01
  - LIB-02
  - LIB-06

must_haves:
  truths:
    - Template name validation rejects path traversal attempts (../etc/passwd)
    - Embedded templates can be retrieved by name without filesystem access
    - XDG user directory takes precedence over embedded templates
    - Invalid template names return security validation errors
  artifacts:
    - path: "Cargo.toml"
      provides: "rust-embed and xdg dependencies"
      contains: "rust-embed"
    - path: "src/template/library.rs"
      provides: "Embedded template access via rust-embed"
      exports: ["EmbeddedTemplates", "list_embedded", "get_embedded"]
    - path: "src/template/resolver.rs"
      provides: "Template resolution with XDG precedence and security validation"
      exports: ["TemplateResolver", "TemplateSource", "validate_template_name"]
    - path: "src/template/mod.rs"
      provides: "Module structure exposing library and resolver"
      contains: "pub mod library"
  key_links:
    - from: "src/template/resolver.rs"
      to: "src/template/library.rs"
      via: "fallback to embedded after XDG lookup"
      pattern: "EmbeddedTemplates::get"
    - from: "src/template/resolver.rs"
      to: "xdg crate BaseDirectories"
      via: "find_data_file for user template lookup"
      pattern: "xdg.*find_data_file"
---

<objective>
Establish the foundational infrastructure for the embedded template library system with secure template resolution.

Purpose: Enable users to reference templates by name without providing file paths, while preventing path traversal attacks and respecting XDG directory precedence.

Output: Core library infrastructure with rust-embed integration, XDG-compliant template resolver, and security validation ready for template population and CLI integration.
</objective>

<execution_context>
@/Users/simonknight/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-template-library-foundation/06-CONTEXT.md
@.planning/phases/06-template-library-foundation/06-RESEARCH.md

# Existing codebase structure
@src/template/mod.rs
@src/template/loader.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Add rust-embed and xdg dependencies</name>
  <files>Cargo.toml</files>
  <action>
Add two new dependencies to the `[dependencies]` section:

```toml
rust-embed = { version = "8.11.0", features = ["compression"] }
xdg = "3.0.0"
```

Use rust-embed 8.11.0 (latest stable) with compression feature enabled to minimize binary size impact. Use xdg 3.0.0 (latest stable) for XDG Base Directory spec compliance.

These crates provide:
- rust-embed: Compile-time embedding of template directory with dual dev/release modes
- xdg: Standard-compliant user/system directory resolution with proper precedence

Place these after the existing `glob` dependency and before `strip-ansi-escapes` to maintain alphabetical grouping of non-clap dependencies.
  </action>
  <verify>cargo check completes without errors; cargo tree shows rust-embed 8.11.0 and xdg 3.0.0 in dependency graph</verify>
  <done>Cargo.toml contains rust-embed and xdg dependencies at specified versions with compression feature enabled</done>
</task>

<task type="auto">
  <name>Create embedded template library module</name>
  <files>src/template/library.rs</files>
  <action>
Create a new file `src/template/library.rs` implementing compile-time template embedding:

**Implementation requirements:**

1. **RustEmbed struct** for template directory:
   - Use `#[derive(RustEmbed)]` with `#[folder = "templates/"]`
   - Include filters: `#[include = "*.yaml"]`, `#[include = "*.toml"]`, `#[include = "*.textfsm"]`
   - Exclude test/doc files: `#[exclude = "*.md"]`, `#[exclude = "tests/*"]`
   - Name the struct `EmbeddedTemplates`

2. **Public functions:**
   - `list_embedded() -> Vec<String>`: Returns all embedded template names using `EmbeddedTemplates::iter()`
   - `get_embedded(name: &str) -> Option<EmbeddedFile>`: Returns template content using `EmbeddedTemplates::get(name)`

3. **Add module documentation** explaining:
   - Templates are embedded at compile time in release builds
   - Templates are loaded from filesystem in debug builds (hot-reload support)
   - Directory path is `templates/` relative to project root

Follow the pattern from RESEARCH.md "Embedding Template Directory" code example. Use rust-embed's RustEmbed derive macro for automatic compile-time embedding.

**Note:** The `templates/` directory doesn't exist yet (created in later plan), but this module compiles correctly with an empty/missing directory.
  </action>
  <verify>cargo check passes; rustdoc for library.rs shows public functions; EmbeddedTemplates struct exists</verify>
  <done>src/template/library.rs provides embedded template access with list_embedded and get_embedded functions</done>
</task>

<task type="auto">
  <name>Create template resolver with security validation</name>
  <files>src/template/resolver.rs</files>
  <action>
Create a new file `src/template/resolver.rs` implementing secure template resolution with XDG precedence:

**Implementation requirements:**

1. **Security validation function** `validate_template_name(name: &str) -> Result<(), String>`:
   - Reject empty names
   - Reject path separators: `/` and `\`
   - Reject parent directory references: `..`
   - Reject absolute path indicators: names starting with `/` or `\`
   - Use allowlist regex pattern: `^[a-zA-Z0-9_\-\.]+$` (alphanumeric, underscore, hyphen, dot only)
   - Return descriptive error messages indicating why validation failed
   - Follow exact pattern from RESEARCH.md "Secure Template Name Validation" including test cases

2. **TemplateSource enum:**
   - `UserFile(PathBuf)`: Template from XDG user directory
   - `Embedded(EmbeddedFile)`: Template from embedded resources

3. **TemplateResolver struct** with XDG integration:
   - Field: `xdg: BaseDirectories` (from xdg crate)
   - `new() -> Result<Self, xdg::BaseDirectoriesError>`: Initialize with `BaseDirectories::with_prefix("cliscrape")`
   - `find_user_template(&self, name: &str) -> Option<PathBuf>`: Use `self.xdg.find_data_file(format!("templates/{}", name))`
   - `resolve(&self, template_name: &str) -> Result<TemplateSource, String>`:
     * Call `validate_template_name` FIRST (before any filesystem operations)
     * Check XDG user directory via `find_user_template`
     * Fallback to embedded via `library::get_embedded`
     * Return error if neither source has the template

4. **XDG directory paths** (documented in comments):
   - User data: `$XDG_DATA_HOME/cliscrape/templates/` (defaults to `~/.local/share/cliscrape/templates/`)
   - System data: `$XDG_DATA_DIRS/cliscrape/templates/` (defaults to `/usr/local/share/cliscrape/templates/:/usr/share/cliscrape/templates/`)

5. **Precedence order** (documented in resolve function):
   - User directory (highest priority)
   - System directories (medium priority)
   - Embedded templates (lowest priority)

Import `EmbeddedFile` from `library` module and `BaseDirectories` from `xdg` crate. Follow patterns from RESEARCH.md "XDG Base Directory Resolution" and "Template Resolution with Security Validation".

**Critical:** Security validation MUST occur before any path construction or filesystem operations to prevent TOCTOU vulnerabilities.
  </action>
  <verify>
cargo test resolver shows validation tests passing; cargo check passes without warnings; validate_template_name rejects "../etc/passwd", accepts "cisco_ios_show_version.yaml"
  </verify>
  <done>src/template/resolver.rs provides TemplateResolver with security validation rejecting path traversal attempts and proper XDG precedence over embedded templates</done>
</task>

<task type="auto">
  <name>Expose library and resolver modules</name>
  <files>src/template/mod.rs</files>
  <action>
Update `src/template/mod.rs` to expose the new library and resolver modules.

**Changes required:**

Add two new module declarations at the top of the file (after existing `pub mod convert`, `pub mod loader`, `pub mod modern`):

```rust
pub mod library;
pub mod resolver;
```

Maintain alphabetical ordering: convert, library, loader, modern, resolver.

Do NOT modify the existing `TextFsmParser` struct or pest grammar declaration. Only add the module declarations.
  </action>
  <verify>cargo check passes; cargo doc shows template::library and template::resolver in module list</verify>
  <done>src/template/mod.rs exposes library and resolver modules making them available to the rest of the codebase</done>
</task>

</tasks>

<verification>

**Functional verification:**

```bash
# Verify dependencies added
cargo tree | grep rust-embed
cargo tree | grep xdg

# Verify modules compile
cargo check --all-targets

# Verify security validation (run unit tests in resolver.rs)
cargo test resolver::tests

# Verify documentation builds
cargo doc --no-deps --document-private-items
```

**Expected outcomes:**
- rust-embed 8.11.0 and xdg 3.0.0 appear in dependency tree
- No compilation errors or warnings
- Security validation tests pass (reject path traversal, accept valid names)
- Module documentation generated for library and resolver

**Code quality checks:**
- Template name validation follows allowlist pattern (not blocklist)
- Validation occurs before any filesystem operations
- XDG precedence is user → system → embedded (correct order)
- Error messages are descriptive and actionable
</verification>

<success_criteria>

Infrastructure must meet these criteria:

1. **Security:** Template name validation rejects all path traversal attempts (`..`, `/`, `\`, absolute paths) before any filesystem operations
2. **XDG Compliance:** Resolver checks user directory (`~/.local/share/cliscrape/templates/`) before embedded templates
3. **Embedded Access:** Library module can list and retrieve embedded templates without filesystem dependency
4. **Clean Integration:** Modules exposed through template::library and template::resolver without breaking existing code
5. **Production Ready:** Dependencies at latest stable versions with compression enabled to minimize binary size

All code compiles without warnings. Security validation tests pass. Documentation builds successfully.
</success_criteria>

<output>
After completion, create `.planning/phases/06-template-library-foundation/06-01-SUMMARY.md`
</output>

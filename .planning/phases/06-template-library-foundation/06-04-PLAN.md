---
phase: 06-template-library-foundation
plan: 04
type: execute
wave: 3
depends_on:
  - 06-01
  - 06-02
  - 06-03
files_modified:
  - templates/cisco_ios_show_version.yaml
  - templates/cisco_ios_show_interfaces.yaml
  - templates/juniper_junos_show_version.yaml
  - templates/arista_eos_show_version.yaml
  - templates/cisco_nxos_show_version.yaml
  - src/template/loader.rs
autonomous: true
requirements:
  - LIB-01
  - LIB-03
  - LIB-05

must_haves:
  truths:
    - User can parse with embedded templates without providing file paths
    - User can override embedded templates by placing custom versions in XDG directory
    - Template names follow ntc-templates convention (vendor_os_command.extension)
    - Embedded templates include complete metadata for discovery
  artifacts:
    - path: "templates/"
      provides: "Embedded template library directory"
      min_lines: 5
    - path: "templates/cisco_ios_show_version.yaml"
      provides: "Cisco IOS show version template with metadata"
      contains: "metadata:"
    - path: "src/template/loader.rs"
      provides: "Template loader integration with resolver"
      contains: "TemplateResolver"
  key_links:
    - from: "src/template/loader.rs"
      to: "src/template/resolver.rs"
      via: "resolve template by name before loading"
      pattern: "resolver.*resolve"
    - from: "templates/*.yaml"
      to: "src/template/library.rs"
      via: "embedded via rust-embed at compile time"
      pattern: "RustEmbed"
---

<objective>
Populate the embedded template library with initial templates and integrate template resolution into the existing loader system.

Purpose: Enable users to parse common network device outputs without providing template files, using embedded templates or XDG user overrides.

Output: Initial template library with 5 curated templates covering major network vendors, fully integrated with existing parse command workflow.
</objective>

<execution_context>
@/Users/simonknight/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-template-library-foundation/06-CONTEXT.md
@.planning/phases/06-template-library-foundation/06-RESEARCH.md

# Infrastructure from prior plans
@.planning/phases/06-template-library-foundation/06-01-SUMMARY.md
@.planning/phases/06-template-library-foundation/06-02-SUMMARY.md
@.planning/phases/06-template-library-foundation/06-03-SUMMARY.md

# Existing template loader
@src/template/loader.rs
@src/template/modern.rs
</context>

<tasks>

<task type="auto">
  <name>Create templates directory and initial library</name>
  <files>
templates/cisco_ios_show_version.yaml
templates/cisco_ios_show_interfaces.yaml
templates/juniper_junos_show_version.yaml
templates/arista_eos_show_version.yaml
templates/cisco_nxos_show_version.yaml
  </files>
  <action>
Create the `templates/` directory at project root and populate with 5 initial templates following ntc-templates naming convention.

**Directory structure:**
```
templates/
├── cisco_ios_show_version.yaml
├── cisco_ios_show_interfaces.yaml
├── juniper_junos_show_version.yaml
├── arista_eos_show_version.yaml
└── cisco_nxos_show_version.yaml
```

**Template naming convention (from RESEARCH.md):**
- Format: `{vendor}_{os}_{command}.{extension}`
- All lowercase
- Underscores separate components
- Command portion describes actual CLI command (spaces → underscores)

**Each template must include:**

1. **Metadata section** (required fields from CONTEXT.md):
```yaml
metadata:
  description: "Parse output of 'show version' command"
  compatibility: "Cisco IOS 12.x, 15.x"
  version: "1.0.0"
  author: "cliscrape"
```

2. **Template structure** using modern YAML format (from existing modern.rs schema):
   - version: "1"
   - Either `states:` (FSM states) or `patterns:` (simple pattern list)
   - For show version: Use `patterns:` for simplicity
   - For show interfaces: Use `states:` for multi-line parsing

**Template content guidelines:**

**cisco_ios_show_version.yaml:**
- Extract: version, uptime, hostname, serial, model
- Pattern-based (no states needed for single-line captures)
- Compatibility: "Cisco IOS 12.x, 15.x, IOS-XE"

**cisco_ios_show_interfaces.yaml:**
- Extract: interface, status, protocol, description, mtu, bandwidth
- State-based (multi-line interface blocks)
- Compatibility: "Cisco IOS 12.x, 15.x"

**juniper_junos_show_version.yaml:**
- Extract: hostname, model, junos_version, serial
- Pattern-based
- Compatibility: "Junos OS 12.x+"

**arista_eos_show_version.yaml:**
- Extract: version, model, serial, uptime
- Pattern-based
- Compatibility: "Arista EOS 4.x+"

**cisco_nxos_show_version.yaml:**
- Extract: version, uptime, hostname, serial, model
- Pattern-based
- Compatibility: "Cisco NX-OS 7.x, 9.x"

**Implementation approach:**
- Use existing modern template schema from src/template/modern.rs
- Reference existing modern templates in tests/ for pattern examples
- Keep patterns simple and focused on key fields
- Include type_hint for numeric fields (uptime as integer where appropriate)
- Use shared macros where applicable (ipv4, interface_name from existing macros.rs)

Do NOT create .textfsm or .toml versions in this initial library. Focus on YAML modern format for consistency and readability.

Follow RESEARCH.md recommendation: "Start with small curated set (5-10 templates) covering common use cases."
  </action>
  <verify>
ls templates/ shows 5 YAML files; cargo build succeeds and embeds templates; cliscrape list-templates shows 5 embedded templates with metadata
  </verify>
  <done>Template library directory created with 5 curated YAML templates covering major vendors (Cisco IOS/NX-OS, Juniper, Arista), each including complete metadata</done>
</task>

<task type="auto">
  <name>Integrate template resolver into loader system</name>
  <files>src/template/loader.rs</files>
  <action>
Update the existing template loader in src/template/loader.rs to support template name resolution via the TemplateResolver.

**Current behavior:** Loader accepts file paths and loads from filesystem only.

**New behavior:** Loader should:
1. Accept either file paths OR template names
2. Use TemplateResolver to resolve names to embedded/user templates
3. Maintain backward compatibility with existing path-based loading

**Implementation changes:**

1. **Add TemplateResolver field** to FsmParser or create a new function:
   - Option A: Add resolver as optional field to existing loader functions
   - Option B: Create new public function `load_template_by_name(name: &str) -> Result<Template>`
   - Recommended: Option B to avoid breaking existing API

2. **New function:** `resolve_template_spec(spec: &str) -> Result<(String, TemplateFormat)>`:
   - If spec is valid path (Path::new(spec).exists()): return (spec, Auto) for file-based loading
   - Else: treat as template name:
     * Create TemplateResolver
     * Call resolver.resolve(spec)
     * Match TemplateSource:
       - UserFile(path) → return (path.to_string(), format_from_extension)
       - Embedded(file) → write to temp file, return (temp_path, format_from_extension)
   - This function bridges the gap between template names and existing file-based loader

3. **Update existing resolve_template_spec function** if it exists:
   - Integrate TemplateResolver lookup before falling back to filesystem
   - Maintain existing error messages for clarity

4. **Error handling:**
   - Template not found: "Template '{name}' not found in embedded library or XDG directories"
   - XDG init failure: "Warning: Could not access user template directory, using embedded templates only"
   - Invalid template name: Forward security validation error from resolver

**Imports needed:**
```rust
use crate::template::resolver::{TemplateResolver, TemplateSource};
```

**Testing approach:**
- Verify embedded template loading: Load "cisco_ios_show_version.yaml" by name
- Verify file path loading still works: Load "./path/to/template.yaml"
- Verify XDG override precedence: User template overrides embedded

Follow existing error handling patterns in loader.rs. Use anyhow for error propagation. Maintain existing API contracts for backward compatibility.

**Critical:** This change enables the `cliscrape parse --template cisco_ios_show_version.yaml` usage pattern specified in Phase 6 success criteria.
  </action>
  <verify>
cargo test loader passes; cargo build succeeds; cliscrape parse --template cisco_ios_show_version.yaml (with sample input) loads embedded template successfully
  </verify>
  <done>Template loader integrated with TemplateResolver enabling template name resolution while maintaining backward compatibility with file path loading</done>
</task>

<task type="auto">
  <name>Create end-to-end integration test</name>
  <files>tests/template_library.rs</files>
  <action>
Create a new integration test file `tests/template_library.rs` verifying the complete template library workflow.

**Test cases to implement:**

1. **test_list_embedded_templates:**
   - Run `cliscrape list-templates --format json`
   - Parse JSON output
   - Assert: 5 templates present (cisco_ios_show_version, cisco_ios_show_interfaces, juniper_junos_show_version, arista_eos_show_version, cisco_nxos_show_version)
   - Assert: Each template has metadata fields (description, compatibility, version, author)

2. **test_show_template_details:**
   - Run `cliscrape show-template cisco_ios_show_version.yaml`
   - Assert: Output contains "Description:", "Compatibility:", "Version:", "Author:", "Source: Embedded"
   - Assert: Output contains "Fields Extracted:" section

3. **test_parse_with_embedded_template:**
   - Create sample Cisco IOS show version output (string literal)
   - Run `cliscrape parse --template cisco_ios_show_version.yaml` with stdin input
   - Assert: JSON output contains expected fields (version, hostname, etc.)
   - Assert: Parsing succeeds without file path

4. **test_template_name_security_validation:**
   - Run `cliscrape parse --template ../etc/passwd`
   - Assert: Error message contains "path traversal not allowed" or similar security error
   - Run `cliscrape parse --template /absolute/path`
   - Assert: Error message indicates absolute paths not allowed

5. **test_filter_templates:**
   - Run `cliscrape list-templates --filter "cisco*" --format json`
   - Parse JSON output
   - Assert: Only Cisco templates returned (cisco_ios_show_version, cisco_ios_show_interfaces, cisco_nxos_show_version)
   - Assert: Juniper and Arista templates NOT in output

**Implementation:**
- Use `assert_cmd::Command` for CLI invocation (already in dev-dependencies)
- Use predicates crate for assertion helpers
- Follow existing test patterns from tests/ directory
- Include sample device output as string literals or separate test fixtures

**Sample test structure:**
```rust
use assert_cmd::Command;
use predicates::prelude::*;

#[test]
fn test_list_embedded_templates() {
    let mut cmd = Command::cargo_bin("cliscrape").unwrap();
    cmd.arg("list-templates")
       .arg("--format").arg("json");

    cmd.assert()
       .success()
       .stdout(predicate::str::contains("cisco_ios_show_version"));
}
```

Include inline documentation explaining what each test verifies and why it's important for library functionality.
  </action>
  <verify>
cargo test --test template_library passes all test cases; embedded templates load correctly; security validation prevents path traversal
  </verify>
  <done>Integration test suite verifies complete template library workflow including listing, details, parsing, security validation, and filtering</done>
</task>

</tasks>

<verification>

**Functional verification:**

```bash
# Verify templates embedded
cargo build --release
./target/release/cliscrape list-templates
# Should show 5 templates with metadata

# Verify template details
./target/release/cliscrape show-template cisco_ios_show_version.yaml
# Should show metadata, source (Embedded), and field list

# Verify parsing with embedded template (create sample input)
echo "Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE11" | \
  ./target/release/cliscrape parse --template cisco_ios_show_version.yaml
# Should parse and output JSON

# Verify security validation
./target/release/cliscrape parse --template ../etc/passwd --input /dev/null
# Should return error about path traversal

# Verify filtering
./target/release/cliscrape list-templates --filter "cisco*"
# Should show only Cisco templates (3 of 5)

# Run integration tests
cargo test --test template_library
# All tests should pass
```

**Expected outcomes:**
- 5 templates appear in list-templates output
- Each template has complete metadata
- Embedded templates load and parse correctly
- Security validation prevents path traversal
- Filter correctly limits output
- XDG override precedence works (test by creating user template)

**Binary size check:**
```bash
ls -lh target/release/cliscrape
# Monitor binary size impact (compression should keep increase minimal)
```
</verification>

<success_criteria>

Template library integration must meet these criteria:

1. **Library Population:** 5 curated templates embedded covering major vendors (Cisco IOS/NX-OS, Juniper, Arista)
2. **Naming Convention:** All templates follow ntc-templates format (vendor_os_command.extension)
3. **Complete Metadata:** Every template includes description, compatibility, version, author
4. **Parse Integration:** Users can parse with embedded templates without providing file paths
5. **Security:** Path traversal attempts rejected by security validation
6. **XDG Override:** User templates in ~/.local/share/cliscrape/templates/ take precedence over embedded
7. **Discovery:** list-templates and show-template commands expose library metadata
8. **Testing:** Integration tests verify complete workflow end-to-end

All tests pass. Embedded templates load correctly. Binary size increase is reasonable (<500KB with compression). Security validation prevents malicious template names.
</success_criteria>

<output>
After completion, create `.planning/phases/06-template-library-foundation/06-04-SUMMARY.md`
</output>

---
phase: 06-template-library-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/template/metadata.rs
  - src/template/mod.rs
  - src/lib.rs
autonomous: true
requirements:
  - LIB-04

must_haves:
  truths:
    - Template metadata can be extracted from YAML/TOML modern templates
    - Template metadata can be extracted from TextFSM comment headers
    - Missing metadata fields default to sensible values without blocking template usage
    - Metadata parsing failures do not prevent template loading
  artifacts:
    - path: "src/template/metadata.rs"
      provides: "Template metadata extraction from all formats"
      exports: ["TemplateMetadata", "extract_metadata"]
      min_lines: 80
    - path: "src/template/mod.rs"
      provides: "metadata module exposure"
      contains: "pub mod metadata"
  key_links:
    - from: "src/template/metadata.rs"
      to: "serde_yaml_ng"
      via: "parse YAML metadata section"
      pattern: "serde_yaml_ng::from_str"
    - from: "src/template/metadata.rs"
      to: "toml"
      via: "parse TOML metadata section"
      pattern: "toml::from_str"
---

<objective>
Implement template metadata extraction supporting all template formats with fault-tolerant defaults.

Purpose: Enable template discovery and information display by extracting required metadata fields (description, compatibility, version, author) from template files without blocking template usage when metadata is incomplete.

Output: Metadata extraction system supporting YAML, TOML, and TextFSM formats with sensible defaults for missing fields.
</objective>

<execution_context>
@/Users/simonknight/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-template-library-foundation/06-CONTEXT.md
@.planning/phases/06-template-library-foundation/06-RESEARCH.md

# Existing template format handling
@src/template/modern.rs
@src/template/loader.rs
@src/cli.rs
</context>

<tasks>

<task type="auto">
  <name>Create metadata extraction module</name>
  <files>src/template/metadata.rs</files>
  <action>
Create a new file `src/template/metadata.rs` implementing fault-tolerant metadata extraction for all template formats.

**Implementation requirements:**

1. **TemplateMetadata struct** with required fields from CONTEXT.md:
   ```rust
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct TemplateMetadata {
       pub description: String,
       pub compatibility: String,
       pub version: String,
       pub author: String,
       #[serde(default)]
       pub maintainer: Option<String>,
   }
   ```

2. **Main extraction function** `extract_metadata(content: &str, format: TemplateFormat) -> TemplateMetadata`:
   - Takes template content string and format enum (from cli.rs)
   - Returns metadata with defaults on any parsing failure
   - Use match on format: `Yaml | Toml` → extract_from_modern, `Textfsm` → extract_from_textfsm_comments, `Auto` → return default_metadata
   - Never propagate errors; always return valid metadata struct

3. **Modern template extraction** `extract_from_modern(content: &str, format: TemplateFormat) -> TemplateMetadata`:
   - For YAML: Parse with `serde_yaml_ng::from_str` into `serde_yaml_ng::Value`
   - For TOML: Parse with `toml::from_str` into `toml::Value`
   - Look for top-level `metadata` key in parsed document
   - If found: deserialize metadata section into TemplateMetadata
   - If not found or parse fails: call `default_metadata()`
   - Wrap all parsing in Result/match; convert errors to defaults

4. **TextFSM comment extraction** `extract_from_textfsm_comments(content: &str) -> TemplateMetadata`:
   - Start with `default_metadata()`
   - Iterate lines until first non-comment line
   - For each line starting with `#`: parse as "Key: Value"
   - Supported keys: "description", "compatibility", "version", "author", "maintainer"
   - Case-insensitive key matching (`.to_lowercase()`)
   - Update metadata struct fields when keys match
   - Return metadata after processing all header comments

5. **Default metadata** `default_metadata() -> TemplateMetadata`:
   - description: "No description available"
   - compatibility: "Unknown"
   - version: "1.0.0"
   - author: "Unknown"
   - maintainer: None

6. **Add unit tests** in `#[cfg(test)] mod tests`:
   - Test YAML metadata extraction (valid metadata section)
   - Test TOML metadata extraction (valid metadata section)
   - Test TextFSM comment extraction (header comments)
   - Test fault tolerance: missing metadata → defaults
   - Test fault tolerance: invalid YAML/TOML → defaults
   - Test TextFSM with no comments → defaults

Follow the pattern from RESEARCH.md "Template Metadata Extraction" code example. Import TemplateFormat from `crate::cli` (already defined in cli.rs).

**Critical:** Metadata extraction must be fault-tolerant. Invalid/missing metadata should never prevent template usage. Always return valid TemplateMetadata struct with sensible defaults.
  </action>
  <verify>
cargo test metadata::tests passes all test cases; cargo check passes; metadata extraction returns defaults for invalid input without panicking
  </verify>
  <done>src/template/metadata.rs provides fault-tolerant metadata extraction for YAML, TOML, and TextFSM formats with comprehensive test coverage</done>
</task>

<task type="auto">
  <name>Expose metadata module and TemplateFormat</name>
  <files>src/template/mod.rs, src/lib.rs</files>
  <action>
Make two small updates to expose the metadata module:

**In src/template/mod.rs:**

Add `pub mod metadata;` to the module declarations (maintaining alphabetical order after `mod.rs` update from plan 01):
- convert
- library
- loader
- metadata
- modern
- resolver

**In src/lib.rs:**

Re-export TemplateFormat from cli module for use in metadata extraction:

```rust
pub use cli::TemplateFormat;
```

This allows `src/template/metadata.rs` to use `crate::TemplateFormat` instead of `crate::cli::TemplateFormat`, keeping the import clean.

Only add the re-export if it doesn't already exist. Do NOT modify any other exports or module structure.
  </action>
  <verify>cargo check passes; cargo doc shows template::metadata in module list; TemplateFormat accessible as crate::TemplateFormat</verify>
  <done>Metadata module exposed and TemplateFormat re-exported for clean imports across codebase</done>
</task>

</tasks>

<verification>

**Functional verification:**

```bash
# Run metadata extraction tests
cargo test metadata::tests -v

# Verify all test cases pass
cargo test metadata -- --nocapture

# Check module documentation
cargo doc --no-deps --document-private-items --open
```

**Test coverage verification:**

Expected test cases:
- Valid YAML metadata extraction (all fields present)
- Valid TOML metadata extraction (all fields present)
- TextFSM header comment extraction (multiple metadata fields)
- Missing metadata section in YAML → returns defaults
- Invalid YAML syntax → returns defaults
- TextFSM with no comments → returns defaults
- Empty content → returns defaults

**Expected outcomes:**
- All tests pass
- Metadata extraction never panics or returns errors
- Default values are sensible and actionable
- Documentation explains fault-tolerance behavior
</verification>

<success_criteria>

Metadata extraction must meet these criteria:

1. **Completeness:** Supports all three template formats (YAML, TOML, TextFSM)
2. **Fault Tolerance:** Invalid/missing metadata returns sensible defaults without errors
3. **Required Fields:** All fields from CONTEXT.md are extracted (description, compatibility, version, author, maintainer)
4. **No Blocking:** Metadata parsing failures do not prevent template usage
5. **Test Coverage:** Unit tests verify extraction and fault tolerance for all formats

All tests pass. Code compiles without warnings. Documentation clearly explains fault-tolerance behavior.
</success_criteria>

<output>
After completion, create `.planning/phases/06-template-library-foundation/06-02-SUMMARY.md`
</output>

---
phase: 06-template-library-foundation
plan: 03
type: execute
wave: 2
depends_on:
  - 06-01
  - 06-02
files_modified:
  - src/cli.rs
  - src/main.rs
autonomous: true
requirements:
  - LIB-02
  - LIB-04

must_haves:
  truths:
    - User can run cliscrape list-templates to see available templates
    - User can run cliscrape show-template NAME to view template details
    - Template listing includes metadata fields in table format
    - Template details show metadata, source location, and optional source code
  artifacts:
    - path: "src/cli.rs"
      provides: "ListTemplates and ShowTemplate subcommands"
      contains: "ListTemplates"
    - path: "src/main.rs"
      provides: "CLI routing for template discovery commands"
      contains: "Commands::ListTemplates"
  key_links:
    - from: "src/main.rs"
      to: "src/template/resolver.rs"
      via: "template resolution for list and show commands"
      pattern: "TemplateResolver::new"
    - from: "src/main.rs"
      to: "src/template/metadata.rs"
      via: "metadata extraction for display"
      pattern: "metadata::extract_metadata"
    - from: "src/main.rs"
      to: "comfy_table"
      via: "table formatting for template listing"
      pattern: "comfy_table::Table"
---

<objective>
Implement CLI subcommands for template discovery and information display.

Purpose: Enable users to discover available templates and view detailed information about specific templates without requiring external documentation or file browsing.

Output: Two new CLI subcommands (list-templates, show-template) integrated with the template resolver and metadata system, producing formatted output for human consumption.
</objective>

<execution_context>
@/Users/simonknight/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simonknight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-template-library-foundation/06-CONTEXT.md
@.planning/phases/06-template-library-foundation/06-RESEARCH.md

# Infrastructure from prior plans
@.planning/phases/06-template-library-foundation/06-01-SUMMARY.md
@.planning/phases/06-template-library-foundation/06-02-SUMMARY.md

# Existing CLI structure
@src/cli.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Add template discovery subcommands to CLI</name>
  <files>src/cli.rs</files>
  <action>
Extend the `Commands` enum in src/cli.rs with two new subcommands for template discovery.

**Add after the Convert subcommand:**

```rust
/// List available templates
#[command(name = "list-templates", alias = "templates")]
ListTemplates {
    /// Filter templates by pattern (supports wildcards)
    #[arg(short, long)]
    filter: Option<String>,

    /// Output format for template listing
    #[arg(short = 'f', long, value_enum, default_value_t = OutputFormat::Table)]
    format: OutputFormat,
},

/// Show detailed information about a specific template
#[command(name = "show-template")]
ShowTemplate {
    /// Template name to display
    template: String,

    /// Show template source code
    #[arg(long)]
    source: bool,
},
```

**Key design decisions (from CONTEXT.md Claude's Discretion):**

- **Command structure:** Use dedicated subcommands (`list-templates`, `show-template`) rather than flags on parse command
- **Filtering:** Simple pattern matching via `--filter` flag (uses glob crate already in dependencies)
- **Output format:** Default to Table for human readability; support JSON for scripting
- **Template names:** Include file extension for explicitness (no format-agnostic resolution)
- **Detail view:** Use `--source` flag to include template source code in output

Place these new commands after the existing `Convert` command and before the closing brace of the `Commands` enum. Maintain consistent formatting with existing commands.

Do NOT modify OutputFormat enum or other existing structures. The OutputFormat::Table variant already exists (used in Parse command).
  </action>
  <verify>cargo check passes; cliscrape --help shows list-templates and show-template in command list; cliscrape list-templates --help shows filter and format options</verify>
  <done>CLI subcommands added for template discovery with filtering and formatting options</done>
</task>

<task type="auto">
  <name>Implement template discovery command handlers</name>
  <files>src/main.rs</files>
  <action>
Add command handlers for the new ListTemplates and ShowTemplate subcommands in the main match statement.

**In the `match cli.command` block, add after the Convert arm:**

```rust
Commands::ListTemplates { filter, format } => {
    handle_list_templates(filter.as_deref(), *format)?;
}
Commands::ShowTemplate { template, source } => {
    handle_show_template(&template, *source)?;
}
```

**Implement handler functions (add before main function):**

1. **handle_list_templates(filter: Option<&str>, format: OutputFormat) -> anyhow::Result<()>:**
   - Create TemplateResolver via `TemplateResolver::new()?`
   - Collect all templates: embedded (via `library::list_embedded()`) + user (via resolver XDG lookup)
   - For each template: extract metadata via `metadata::extract_metadata(content, format_from_extension(name))`
   - Apply filter if provided: use `glob::Pattern::new(pattern)?.matches(name)`
   - Sort by name for consistent output
   - Match on format:
     * `OutputFormat::Table`: Use comfy_table with columns [Name, Description, Compatibility, Version, Source]
     * `OutputFormat::Json`: Serialize as JSON array of objects
     * `OutputFormat::Auto`: Default to Table
     * `OutputFormat::Csv`: Return error "CSV format not supported for template listing"
   - Print output to stdout

2. **handle_show_template(name: &str, show_source: bool) -> anyhow::Result<()>:**
   - Create TemplateResolver via `TemplateResolver::new()?`
   - Resolve template via `resolver.resolve(name)?`
   - Load template content (handle both TemplateSource::UserFile and TemplateSource::Embedded)
   - Extract metadata via `metadata::extract_metadata(content, format_from_extension(name))`
   - Load template to get field list (use existing loader.rs logic)
   - Print formatted output:
     * Template: {name}
     * Description: {metadata.description}
     * Compatibility: {metadata.compatibility}
     * Version: {metadata.version}
     * Author: {metadata.author}
     * Maintainer: {metadata.maintainer} (if present)
     * Source: "User Override ({path})" or "Embedded"
     * Fields Extracted: (bulleted list)
   - If show_source: print template source with separator lines
   - All output to stdout

3. **Helper function format_from_extension(name: &str) -> TemplateFormat:**
   - Match on file extension: ".yaml" → Yaml, ".toml" → Toml, ".textfsm" → Textfsm
   - Default to Auto for unknown extensions

**Imports needed at top of main.rs:**
```rust
use cliscrape::template::{library, metadata, resolver::{TemplateResolver, TemplateSource}};
use comfy_table::{Table, presets};
```

Follow patterns from RESEARCH.md "Template Listing with Metadata" and "Template Detail Display" code examples. Use existing error handling patterns from main.rs (anyhow::Result return type).

**Error handling:**
- Template not found: Return descriptive error with available template count
- Invalid filter pattern: Return error with pattern syntax hint
- XDG initialization failure: Provide fallback error message suggesting embedded-only usage
  </action>
  <verify>
cargo build succeeds; cliscrape list-templates shows table with embedded templates (empty until plan 04); cliscrape show-template nonexistent returns error; cliscrape list-templates --filter "cisco*" applies filter correctly
  </verify>
  <done>Template discovery commands route to handlers that resolve templates, extract metadata, and format output according to user preferences</done>
</task>

</tasks>

<verification>

**Functional verification:**

```bash
# Build and verify CLI help
cargo build --release
./target/release/cliscrape --help | grep -E "(list-templates|show-template)"
./target/release/cliscrape list-templates --help
./target/release/cliscrape show-template --help

# Test list-templates command (will be empty until plan 04)
./target/release/cliscrape list-templates
./target/release/cliscrape list-templates --format json

# Test show-template error handling
./target/release/cliscrape show-template nonexistent_template.yaml
# Should return error: Template 'nonexistent_template.yaml' not found

# Test filter pattern (will be empty until plan 04)
./target/release/cliscrape list-templates --filter "cisco*"
```

**Expected outcomes:**
- Commands appear in `cliscrape --help` output
- list-templates shows empty table or JSON array (no templates embedded yet)
- show-template returns descriptive error for nonexistent templates
- Invalid filter patterns return error with syntax hint
- Table formatting uses comfy-table with clear column headers
- JSON output is valid, parseable JSON

**Edge cases to verify:**
- Empty template library (graceful handling, not crash)
- Invalid glob patterns (error, not panic)
- Template name without extension (handled by resolver validation)
</verification>

<success_criteria>

CLI integration must meet these criteria:

1. **Command Availability:** list-templates and show-template appear in cliscrape --help
2. **Metadata Display:** Template listing includes all required metadata fields (description, compatibility, version, author)
3. **Source Location:** Template details indicate whether template is embedded or user override
4. **Field Extraction:** show-template displays list of fields captured by template
5. **Format Support:** list-templates supports Table and JSON output formats
6. **Error Handling:** Graceful errors for nonexistent templates and invalid filters
7. **Optional Source:** show-template --source flag includes template source code

Commands execute without panics. Empty template library handled gracefully. Output formatting is clean and human-readable.
</success_criteria>

<output>
After completion, create `.planning/phases/06-template-library-foundation/06-03-SUMMARY.md`
</output>

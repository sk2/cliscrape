---
phase: 04-tui-debugger-foundation-(live-lab)
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/engine/mod.rs
  - src/engine/fsm.rs
  - src/engine/debug.rs
  - src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Engine can produce a per-line match trace (including Continue stacking) for a given template + input"
    - "Debug trace includes capture byte spans usable for UI highlighting"
    - "Debug trace includes emitted records and their originating line index"
  artifacts:
    - path: "src/engine/debug.rs"
      provides: "DebugReport + trace data model"
      exports: ["DebugReport", "LineMatch", "CaptureSpan", "EmittedRecord"]
    - path: "src/engine/fsm.rs"
      provides: "Template::debug_parse implementation"
      contains: "debug_parse"
    - path: "src/lib.rs"
      provides: "Public API for debug parsing via FsmParser"
      contains: "debug_parse"
  key_links:
    - from: "src/engine/fsm.rs"
      to: "src/engine/debug.rs"
      via: "Template::debug_parse builds DebugReport"
      pattern: "DebugReport"
    - from: "src/lib.rs"
      to: "src/engine/fsm.rs"
      via: "FsmParser forwards to Template::debug_parse"
      pattern: "debug_parse\("

---

<objective>
Add a debug-parse API that returns a UI-friendly trace: per-line matches (with Continue stacking), capture spans, and emitted records.

Purpose: The TUI needs stable per-line match context and capture spans to render highlights and rule context without re-implementing parsing logic.
Output: `DebugReport` data model + `Template::debug_parse` + public `FsmParser::debug_parse` wrapper.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-tui-debugger-foundation-(live-lab)/04-CONTEXT.md
@.planning/phases/04-tui-debugger-foundation-(live-lab)/04-RESEARCH.md

@src/engine/fsm.rs
@src/engine/records.rs
@src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Define DebugReport trace model for TUI consumption</name>
  <files>
Cargo.toml
src/engine/mod.rs
src/engine/debug.rs
  </files>
  <action>
- Create `src/engine/debug.rs` containing a minimal, serializable (Debug/Clone) trace model:
  - `DebugReport { lines: Vec<DebugLine>, matches_by_line: Vec<Vec<LineMatch>>, records: Vec<EmittedRecord> }` (exact shape may vary but must support: raw line text, per-line stacked matches, emitted records).
  - `LineMatch` includes: `line_idx`, `state_before`, `state_after`, `rule_idx`, `line_action`, `record_action`, `next_state` (if any), and `captures: Vec<CaptureSpan>`.
  - `CaptureSpan` includes: `name`, `start_byte`, `end_byte`, `raw`, `typed: serde_json::Value`, `is_list`.
  - `EmittedRecord` includes: `line_idx` and full emitted `record: HashMap<String, serde_json::Value>`.
- Export the module from `src/engine/mod.rs` and keep it engine-internal public (`pub mod debug;`).
- Do NOT add any UI dependencies here (ratatui/crossterm stay in the binary crate).
  </action>
  <verify>cargo test</verify>
  <done>`src/engine/debug.rs` exists and compiles; types are usable from `cliscrape::engine`.</done>
</task>

<task type="auto">
  <name>Implement Template::debug_parse using the real FSM loop</name>
  <files>
src/engine/fsm.rs
  </files>
  <action>
- Implement `Template::debug_parse(&self, input: &str) -> Result<DebugReport, ScraperError>`.
- Reuse the same parsing loop/semantics as `Template::parse`:
  - Preserve `Continue` behavior (multiple matches per line must be recorded in match order).
  - Preserve state transitions and `End` termination.
  - Preserve record buffer semantics (`Filldown`, `Required`, list accumulation).
- For each successful rule match:
  - Record a `LineMatch` entry for the current line with state/rule/actions before advancing.
  - For each named capture, record `CaptureSpan` with byte offsets from `regex::Match` (`start()`/`end()`) plus `raw`.
  - Compute `typed` using existing conversion logic (`convert_scalar`) and the field's `type_hint`; for list fields, typed value for each capture should reflect the scalar conversion of that capture.
- When record emission occurs, also record an `EmittedRecord { line_idx, record }` alongside the normal results.
- The returned `DebugReport` must include the original `input.lines()` text (store as `Vec<String>` to avoid lifetime issues).
  </action>
  <verify>cargo test</verify>
  <done>`Template::debug_parse` returns a trace with per-line stacked matches, capture spans, and emitted record entries.</done>
</task>

<task type="auto">
  <name>Expose debug parsing through FsmParser and add regression tests</name>
  <files>
src/lib.rs
src/engine/fsm.rs
  </files>
  <action>
- In `src/lib.rs`, add `pub fn debug_parse(&self, input: &str) -> Result<engine::debug::DebugReport, ScraperError>` on `FsmParser` that forwards to `self.template.debug_parse(input)`.
- Re-export the debug types if needed for the binary crate ergonomics (e.g., `pub use engine::debug::DebugReport;`).
- Add focused unit tests (in `src/engine/fsm.rs` test module or a new `src/engine/debug.rs` test module) that verify:
  - Continue stacking: one line can produce 2+ `LineMatch` entries.
  - Capture spans: `start_byte..end_byte` slice equals `raw` for ASCII input.
  - Record emission: `debug_parse(...).records[*].record` equals `parse(...)` output for the same template/input.
  </action>
  <verify>cargo test</verify>
  <done>Tests pass and `cliscrape::FsmParser::debug_parse` is available for the TUI.</done>
</task>

</tasks>

<verification>
- `cargo test`
</verification>

<success_criteria>
- Debug trace is derived from the real FSM loop (no duplicated parsing logic).
- Trace is stable enough for UI: per-line matches, capture spans, and emitted records are all present.
</success_criteria>

<output>
After completion, create `.planning/phases/04-tui-debugger-foundation-(live-lab)/04-01-SUMMARY.md`
</output>

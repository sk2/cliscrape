---
phase: 04-tui-debugger-foundation-(live-lab)
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - Cargo.toml
  - src/cli.rs
  - src/main.rs
  - src/tui/mod.rs
  - src/tui/app.rs
  - src/tui/ui.rs
  - src/tui/event.rs
autonomous: true

must_haves:
  truths:
    - "User can launch `cliscrape debug` and see a 3-pane TUI"
    - "User can move a line cursor with arrow keys or vim keys"
    - "Selected line drives match/details panes (lockstep panes)"
  artifacts:
    - path: "src/tui/app.rs"
      provides: "AppState and selection model"
    - path: "src/tui/ui.rs"
      provides: "3-pane draw(frame, &AppState)"
    - path: "src/main.rs"
      provides: "Debug subcommand dispatch into TUI"
  key_links:
    - from: "src/main.rs"
      to: "src/tui/mod.rs"
      via: "Commands::Debug -> tui::run_debugger"
      pattern: "Commands::Debug"
    - from: "src/tui/app.rs"
      to: "src/tui/ui.rs"
      via: "cursor_line_idx selects per-line DebugReport view"
      pattern: "cursor_line"

---

<objective>
Create the initial Live Lab TUI scaffolding (3 panes + navigation) and wire it to `cliscrape debug`.

Purpose: Establish the event loop + UI layout and prove the debug report can be rendered interactively.
Output: `src/tui/*` module, CLI debug args, and an interactive TUI that can render matches for a given template+input.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-tui-debugger-foundation-(live-lab)/04-CONTEXT.md
@.planning/phases/04-tui-debugger-foundation-(live-lab)/04-RESEARCH.md

@src/main.rs
@src/cli.rs
@src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Extend CLI debug command to accept template + input paths</name>
  <files>src/cli.rs</files>
  <action>
- Update `Commands::Debug` to accept:
  - `--template/-t <PATH>` (optional)
  - `--input/-i <PATH>` (optional)
- Keep both optional so the TUI can show an in-app picker when missing (implemented later).
- Ensure `cliscrape debug --help` clearly documents the flags.
  </action>
  <verify>cargo run -- --help</verify>
  <done>`cliscrape debug` supports optional `--template` and `--input` flags.</done>
</task>

<task type="auto">
  <name>Add Ratatui app skeleton with message-driven event loop</name>
  <files>
Cargo.toml
src/tui/mod.rs
src/tui/app.rs
src/tui/ui.rs
src/tui/event.rs
  </files>
  <action>
- Ensure `Cargo.toml` has the required deps for this plan:
  - `ratatui` (with `crossterm` backend feature enabled)
  - `crossterm`
  - If missing, add via:
    - `cargo add ratatui@0.30.0 --features crossterm`
    - `cargo add crossterm@0.29.0`
- Create `src/tui/` with the structure recommended in research (app/ui/event split).
- Implement a single-threaded immediate-mode loop using the standard Ratatui + Crossterm setup (do not assume a helper like `ratatui::run(...)` exists):
  - Terminal init: `crossterm::terminal::enable_raw_mode()`, `EnterAlternateScreen`, create `Terminal<CrosstermBackend<Stdout>>`.
  - Main loop: `terminal.draw(|f| ui::draw(f, &app))` then `crossterm::event::poll(timeout)` + `event::read()`; convert events into a small `Message`/`Action` model in `src/tui/event.rs`.
  - Cleanup on exit (including error path): `LeaveAlternateScreen`, `disable_raw_mode()`, `terminal.show_cursor()`.
  - Maintain `AppState` with: loaded template path (Option), loaded input path (Option), current lines (Vec<String>), cursor line index, and last `DebugReport` (Option).
  - Key handling: support both arrows and vim keys at minimum: Up/Down + j/k; quit with q/Esc.
  - Layout: 3 panes (left raw lines; right top matches list; right bottom details).
- Wiring requirement: when `cursor line index` changes, the match+details panes must render the view for that selected line by indexing into the current `DebugReport` (i.e., cursor drives panes in lockstep; no independent selection state in the right panes).
- In this plan, it is acceptable for the match/details panes to be minimal (e.g., show counts + first match) as long as the layout and navigation exist.
  </action>
  <verify>cargo build</verify>
  <done>`src/tui/*` compiles and renders a 3-pane UI that responds to navigation keys.</done>
</task>

<task type="auto">
  <name>Wire Commands::Debug to launch the TUI and render first debug parse</name>
  <files>src/main.rs</files>
  <action>
- Replace the placeholder `Commands::Debug` branch with a call into `tui::run_debugger(template, input)`.
- In `tui::run_debugger`, when both template+input are provided:
  - Load template via `FsmParser::from_file(...)`.
  - Read input file as string and apply `transcript::preprocess_ios_transcript`, selecting the first block by default.
  - Call `parser.debug_parse(block)` and store the `DebugReport` in `AppState`.
- When either path is missing, show an in-app empty state screen (no picker yet) with instructions and the currently missing fields.
- Verification fixture: this plan assumes repo fixtures exist at `templates/modern/ios_show_interfaces.yaml` and `examples/output.txt`; if either is missing, do not substitute paths here (add a minimal fixture file in a later plan instead).
  </action>
  <verify>cargo run -- debug --template templates/modern/ios_show_interfaces.yaml --input examples/output.txt</verify>
  <done>`cliscrape debug` launches the TUI and can render debug parse results when paths are provided.</done>
</task>

</tasks>

<verification>
- `cargo build`
- Manual sanity: run `cargo run -- debug --template templates/modern/ios_show_interfaces.yaml --input examples/output.txt`, navigate up/down, quit with `q`.
</verification>

<success_criteria>
- 3-pane layout exists and does not flicker or crash.
- Line cursor navigation updates selection state.
</success_criteria>

<output>
After completion, create `.planning/phases/04-tui-debugger-foundation-(live-lab)/04-02-SUMMARY.md`
</output>
